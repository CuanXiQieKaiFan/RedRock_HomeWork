# 2021Web后端期末测试

## 说明

- 测试时间： 14：00 - 18：00写到自己满意就可以离开
- 提交方式：现场提交
- 有问题问在场的学长
- 抄袭是坏文明
- 合理利用之前的作业、课件、搜索引擎，~~如有直接cv的代码请注明出处并加上自己详细的注释~~
- **请合理安排时间，不要死磕一道题**

## 1.并发相关

### (a)

```go
func main() {
	var mu sync.Mutex

	go func() {
		fmt.Println("有点强人锁男")
		mu.Lock()
	}()
	
	mu.Unlock()
}
```

这段代码在运行之后可能会报错，请解释原因



答：func()是一个协程，同时和main()一起执行，这里main()中的 mu.Unlock() 可能会比

协程func()中的 mu.Lock()先调用，则会出现fatal error: sync: unlock of unlocked mutex 这种错误

将代码修改为 mu.Lock() 设置在go fun() 之前则可保证运行正常。



### (b)

在``go``语言中使用`sync.Mutex`互斥锁同步是比较低级的做法，我们可以尝试使用管道``Channel``的堵塞来实现同步，

请对下面代码添加``Channel``，使之可以正常输出。

```go
func main() {

	go func() {
		fmt.Println("下山的路又堵起了")
	}()
	
}
```



答： 代码如下：

```go
func main() {
	var ch = make(chan int)
	go func() {
		fmt.Println("下山的路又堵起了")
        <-ch                         //无缓存，发送要在接受前
	}()
    ch<-1
}

```



### (c)

**基于管道**，我们可以把打印的协程拓展为N个。

请在``main``函数中开启10个协程输出一段话，要求10行话全部输出完毕后再结束``main``函数。



答：代码如下：

```go
func main() {
	ch := make(chan int, 10) // 带 10 个缓存

	// 开10个后台打印线程
	for i := 0; i < cap(ch); i++ {
		go func(){
			fmt.Println("吃个桃桃，好凉凉喔！")
			ch <- 1
		}()
	}

	// 等待10个后台线程完成
	for i := 0; i < cap(ch); i++ {
		<-ch
	}
}
```



### (d)

使用并发操作可以提高程序的运行速度，请实现高并发求一百万之内的所有素数

如果你参考了网络上的文章/程序，请附带上包含你个人理解的注释and被你参考文章/程序的链接



答：真是 "强人锁男"。

参考网站：https://blog.csdn.net/weixin_44510363/article/details/109614416?ops

```go
package main

import (
	"fmt"
	"sync"
	"time"
)

var wg sync.WaitGroup
var lock sync.Mutex

// 统计素数个数
var counter = 0

// inputNumbers 产生数据
func inputNumbers(startNumber, endNumber int, inner chan<- int) {
	for i := startNumber; i < endNumber; i++ {
		inner <- i
	}
	close(inner)
	wg.Done()
}

// prime 生产素数，存入通道 primer
func prime(inner <-chan int, primer, flag chan<- int) {
	for i := range inner {
		flag := true
		// 除到一半即可判断出是否为素数
		// 加1是防止生产的数据为单数，如5555等
		for j := 2; j < i/2+1; j++ {
			// 判断是否为素数，不是则跳出内层循环
			if i%j == 0 {
				flag = false
				break
			}
		}
		if flag && i != 1 {
			// 将素数发送到通道
			primer <- i
			lock.Lock() // 加锁
			counter++
			lock.Unlock() // 解锁
		}
	}
	flag <- 1
	wg.Done()
}

// printPrime 打印素数
func printPrime(primer <-chan int) {
	for _ = range primer {
		// for v := range primer {
		// fmt.Print(v, " ")
	}
	fmt.Println("\nTotal primes:", counter)
	wg.Done()
}

func main() {
	start := time.Now()
	// inner 生产者通道，生产原始数据
	inner := make(chan int, 1000)
	// primer 消费原始数据，生产素数
	primer := make(chan int, 1000)
	// flag 设置 primer 结束标记，容量设为开启协程数量
	flag := make(chan int, 10)

	wg.Add(1)
	go inputNumbers(1, 1000000, inner) // 1~1000000

	// 开启 cap(flag) 个协程，获取素数
	for i := 0; i < cap(flag); i++ {
		wg.Add(1)
		go prime(inner, primer, flag)
	}
	wg.Add(1)
	go printPrime(primer)

	wg.Add(1)
	go func() {
		for {
			// 若长度与容量相等，表示已经完成所有素数生产，
			// 可以关闭通道 primer，跳出无限循环
			if len(flag) == cap(flag) {
				close(primer)
				wg.Done()
				break
			}
		}
	}()

	wg.Wait()
	end := time.Now()
	// 计算耗费时间
	fmt.Println("Total time  :", end.Sub(start))
}

```

个人理解： 我的想法是，将1000000分成100份，第一份为1~10000，第二份为10001~20000....同时对这100份数据进行素数查找，使用 sync.WaitGroup来实现群组同步，提高程序的运行效率。



## 2.编码能力题

### 登dua廊

#### 题面

> 邓捷：对了，我叫阿捷，我也常来这里玩，他们都叫我捷哥，你们好，我一个人住，我的房子还蛮大的，欢迎你们来我家玩。玩累了就直接睡觉，没问题的。

> 嘉伟：那捷哥，我跟我朋友今天就去你家住啰～

~~于是在命运红线的牵引下，少年和少年相遇了~~

阿伟要前往捷哥的大house，但是首先需要登上高高的dua廊。

捷哥告诉阿伟：我的房子**共有``N+1``层**，我就住在顶层。**除了顶层外**，我的楼另有N层，每层M个房间，这M个房间**围成一圈**并**按逆时针方向**依次编号为``0…M-1``。其中一些房间有通往上一层的楼梯，另一些没有，每层楼的楼梯设计可能不同。

每个房间里有一个指示牌，指示牌上有一个数字``x``，**表示从这个房间开始按逆时针方向选择第``x``个有楼梯的房间**。假定该房间的编号为k，从该房间上楼，上楼后到达上一层的``k``号房间。比如当前房间的指示牌上写着2，则按逆时针方向开始尝试，找到第2个**有楼梯**的房间，从该房间上楼。如果当前房间本身就有楼梯通向上层，该房间作为第一个有楼梯的房间。

帮助找到每层上楼房间的指示牌上的数字（即每层第一个进入的房间内指示牌上的数字）总和为顶层捷哥屋子的密码。

请热心的你写一个程序，帮助阿伟算出密码。

你的程序需要满足所有符合要求的输入，都可以算出正确的密码。

#### 输入格式

第一行2个整数``N``和``M``，之间用一个空格隔开。

``N``表示除了顶层共``N``层楼，``M``表示除顶层外每层楼有``M``个房间。

接下来``N×M``行，每行两个整数，之间用一个空格隔开，每行描述一个房间内的情况，其中第``(i−1)×M+j``行表示第``i``层``j−1``号房间的情况``（i=1,2,…,N；j=1,2,…,M）``。

第一个整数表示该房间是否有楼梯通往上一层（``0``表示没有，``1``表示有），第二个整数表示指示牌上的数字。

注意，从``j``号房间的楼梯爬到上一层到达的房间一定也是``j``号房间。

最后一行，一个整数，表示阿伟从楼底层的几号房间进入开始登dua廊**（注：房间编号从0开始）**。

**你的程序需要对所有符合条件的输入，给出正确的输出**

#### 输出格式

一个整数，表示打开捷哥房间的密码。

#### 样例

样例输入1

```
2 3
1 2
0 3
1 4
0 1
1 5
1 2
1
```

样例输出1

```
5
```

样例说明1

```
第一层
0号房间，有楼梯通往上层，指示牌上的数字是2 
1号房间，无楼梯通往上层，指示牌上的数字是3 
2号房间，有楼梯通往上层，指示牌上的数字是4 
第二层
0号房间，无楼梯通往上层，指示牌上的数字是1 
1号房间，有楼梯通往上层，指示牌上的数字是5 
2号房间，有楼梯通往上层，指示牌上的数字是2

阿伟首先进入第一层“底层”的1号房间，记下指示牌上的数字为3，然后从这个房间开始，沿逆时针方向选择第3个有楼梯的房间2号房间进入，上楼后到达第二层的2号房间，记下指示牌上的数字为2，由于当前房间本身有楼梯通向上层，该房间作为第一个有楼梯的房间。因此，此时沿逆时针方向选择第2个有楼梯的房间即为1号房间，进入后上楼梯到达顶层。这时把上述记下的指示牌上的数字加起来，即3+2=5，所以密码就是5。
```

#### 补充说明

很多时候作为后端开发，我们需要处理一些非常复杂的逻辑，所以对编码能力会有较高的要求。

这题只是题面又长又绕，但是当你get到题意之后，会发现其实并不难，

如果代码实在实现不了，叙述一下你的思路也可以。



答： 思路：

  每一层的房间逆时针围成一个圈，我的想法是构建一个循环队列，对每一层的每一个房间进行判断，且判断一次删除一个，找到可以通往上一层的房间，并把其房间号传入通道，实现M个并发程序，同时判断每一层，最后将每一层传入通道的数据接受并求和得到最终密码。



## 3. 业务题

### 3G含金量

在2077年，cqupt发行了“3G币”以取代陈旧的重邮一卡通系统

请实现以下功能：

- 登陆，注册
- 给自己充值
- 用户之间转账（考虑dao层error,确保不会出现A余额增加B余额不变的情况，且不应出现负数）
- 给自己的交易记录增加备注
- 根据备注能够模糊查询交易记录
- 部署到自己的服务器上，并提供一个help接口，返回自己实现了哪些接口
- 可以添加一份README.md文件，加上你的项目说明

**附加题：**

- 一份经过测试的接口文档
- 设置定时扣费
- 生存转账链接，点击链接后视为向对方转账
- 提供一个接口，返回上述链接的二维码
- 实现一切你可以想到的新功能，并提供在help接口
- 使用一切你会的新技术

答：我G了，这个太麻烦了。

